---
title: "M√≥dulo 3: Flujo de Trabajo y Prompting Avanzado"
description: Domina Inline Edit y Composer, implementa t√©cnicas avanzadas de prompting, evita anti-patrones comunes y establece ciclos √≥ptimos de desarrollo para m√°xima productividad.
---

import { Card, CardGrid } from '@astrojs/starlight/components';

# M√≥dulo 3: Flujo de Trabajo y Prompting Avanzado

## Objetivos de Aprendizaje

Al finalizar este m√≥dulo, ser√°s capaz de:

1. **Dominar Inline Edit (‚åòK)** para ediciones precisas, refactoring incremental y correcciones puntuales
2. **Optimizar Composer (‚åòI)** para conversaciones multi-turno contextuales y desarrollo de features complejas
3. **Implementar t√©cnicas avanzadas de prompting**: anatom√≠a efectiva, few-shot learning y chain-of-thought
4. **Identificar y evitar anti-patrones comunes** que reducen la efectividad de la IA
5. **Establecer ciclos √≥ptimos** de prompt ‚Üí revisi√≥n ‚Üí aplicaci√≥n para m√°xima productividad
6. **Configurar AI Commit Messages** y supervisi√≥n inteligente de cambios

## üìπ Videos del M√≥dulo

### üéØ Video Principal: Workflows y Prompting Avanzado

Domina t√©cnicas avanzadas de prompting y workflows profesionales.

<iframe 
  width="100%" 
  height="400" 
  src="https://www.youtube.com/embed/3289vhOUdKA" 
  title="Workflows y Prompting Avanzado" 
  frameborder="0" 
  allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" 
  allowfullscreen
  style="border-radius: 8px; margin: 1rem 0;">
</iframe>

### üõ†Ô∏è Video Complementario: T√©cnicas de Configuraci√≥n

Profundiza en configuraciones avanzadas y optimizaci√≥n del entorno.

<iframe 
  width="100%" 
  height="400" 
  src="https://www.youtube.com/embed/5zR1ZE5aqho" 
  title="T√©cnicas Avanzadas de Configuraci√≥n" 
  frameborder="0" 
  allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" 
  allowfullscreen
  style="border-radius: 8px; margin: 1rem 0;">
</iframe>

## Introducci√≥n Conceptual

El dominio del flujo de trabajo con Cursor AI representa la diferencia entre un desarrollador que usa IA ocasionalmente y uno que ha **transformado completamente su productividad**. Este m√≥dulo se enfoca en desarrollar la **intuici√≥n de prompting**‚Äîla habilidad de comunicar intenci√≥n t√©cnica de forma que los agentes de IA generen exactamente lo que necesitas.

Los desarrolladores m√°s efectivos con Cursor AI no son necesariamente los que conocen m√°s funcionalidades, sino los que han desarrollado un **lenguaje com√∫n con la IA**: saben cu√°ndo usar Inline Edit vs Composer, c√≥mo estructurar prompts para diferentes tipos de tareas, y c√≥mo mantener conversaciones t√©cnicas productivas que construyan iterativamente hacia soluciones complejas.

Este flujo de trabajo optimizado puede **multiplicar la velocidad de desarrollo por 3-5x** mientras mantiene o mejora la calidad del c√≥digo.

## Flujo de Trabajo B√°sico

### Inline Edit (‚åòK): Ediciones R√°pidas y Refactoring

#### ¬øCu√°ndo Usar Inline Edit?

Inline Edit es ideal para:

- ‚úÖ **Transformaciones espec√≠ficas** de c√≥digo existente
- ‚úÖ **Refactoring incremental** de funciones o componentes  
- ‚úÖ **Correcciones puntuales** de bugs identificados
- ‚úÖ **Optimizaciones de performance** localizadas
- ‚úÖ **Conversiones de formato** (callbacks ‚Üí async/await, classes ‚Üí hooks)

#### T√©cnicas Avanzadas de Inline Edit

##### 1) Refactoring de Funciones Legacy

```javascript
// C√≥digo original (seleccionar toda la funci√≥n)
function fetchUserData(userId, callback) {
  fetch(`/api/users/${userId}`)
    .then(response => response.json())
    .then(data => callback(null, data))
    .catch(error => callback(error, null));
}

// Prompt para Inline Edit: ‚åòK
// "Convert to async/await with proper error handling and TypeScript types"

// Resultado esperado:
async function fetchUserData(userId: string): Promise<UserData> {
  try {
    const response = await fetch(`/api/users/${userId}`);
    
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    
    const userData: UserData = await response.json();
    return userData;
  } catch (error) {
    console.error('Failed to fetch user data:', error);
    throw error;
  }
}
```

##### 2) Optimizaci√≥n de Componentes React

```tsx
// C√≥digo original (seleccionar el componente completo)
const UserList = ({ users }) => {
  return (
    <div>
      {users.map(user => (
        <div key={user.id} onClick={() => handleUserClick(user.id)}>
          <img src={user.avatar} alt={user.name} />
          <span>{user.name}</span>
          <span>{user.email}</span>
        </div>
      ))}
    </div>
  );
};

// Prompt para Inline Edit: ‚åòK
// "Optimize for performance with React.memo, useCallback, and proper TypeScript"

// Resultado esperado:
interface User {
  id: string;
  name: string;
  email: string;
  avatar: string;
}

interface UserListProps {
  users: User[];
  onUserClick: (userId: string) => void;
}

const UserList: React.FC<UserListProps> = React.memo(({ users, onUserClick }) => {
  return (
    <div className="user-list">
      {users.map(user => (
        <UserListItem 
          key={user.id} 
          user={user} 
          onUserClick={onUserClick}
        />
      ))}
    </div>
  );
});

interface UserListItemProps {
  user: User;
  onUserClick: (userId: string) => void;
}

const UserListItem: React.FC<UserListItemProps> = React.memo(({ user, onUserClick }) => {
  const handleClick = useCallback(() => {
    onUserClick(user.id);
  }, [user.id, onUserClick]);

  return (
    <div className="user-item" onClick={handleClick}>
      <img 
        src={user.avatar} 
        alt={user.name}
        loading="lazy"
        className="user-avatar"
      />
      <span className="user-name">{user.name}</span>
      <span className="user-email">{user.email}</span>
    </div>
  );
});
```

##### 3) Estrategias de Selecci√≥n √ìptima

```typescript
// T√©cnicas de selecci√≥n para mejores resultados
interface SelectionStrategies {
  // Selecci√≥n precisa: solo lo que necesita cambio
  precise_selection: {
    target: "L√≠neas exactas a modificar";
    context: "M√≠nimo contexto circundante";
    example: "Seleccionar solo funci√≥n problem√°tica, no archivo completo";
  };
  
  // Selecci√≥n expandida: para refactoring complejo
  expanded_selection: {
    target: "Funci√≥n + dependencias directas";
    context: "Types, interfaces, imports relevantes";
    example: "Componente + props interface + helper functions";
  };
  
  // Selecci√≥n de bloque l√≥gico: unidad completa
  logical_block: {
    target: "M√≥dulo o clase completa";
    context: "Todas las dependencias internas";
    example: "Custom hook completo con tipos y tests";
  };
}
```

### Composer (‚åòI): Conversaciones Multi-Turno

#### ¬øCu√°ndo Usar Composer?

Composer es ideal para:

- ‚úÖ **Generaci√≥n de c√≥digo nuevo** desde cero
- ‚úÖ **An√°lisis arquitectural** y toma de decisiones
- ‚úÖ **Resoluci√≥n de problemas complejos** que requieren m√∫ltiples pasos
- ‚úÖ **Documentaci√≥n y explicaciones** detalladas
- ‚úÖ **Planificaci√≥n de features** antes de implementaci√≥n

#### T√©cnicas de Conversaciones Efectivas

##### 1) Estructura de Conversaci√≥n Ideal

```javascript
// Patr√≥n: Contexto ‚Üí Requerimientos ‚Üí Iteraci√≥n ‚Üí Refinamiento

// Turno 1: Establecer contexto completo
const initialPrompt = `
Estoy desarrollando un sistema de autenticaci√≥n para una app React + FastAPI.

Contexto del proyecto:
- Frontend: React 18 + TypeScript + Zustand
- Backend: FastAPI + SQLAlchemy + PostgreSQL
- Autenticaci√≥n: JWT con refresh tokens
- Dise√±o: TailwindCSS siguiendo nuestro design system

Necesito implementar:
1. Login/registro con validaci√≥n
2. Manejo de sesiones persistentes
3. Rutas protegidas
4. Password reset

¬øPodr√≠as ayudarme a dise√±ar la arquitectura general y empezar con el store de autenticaci√≥n?
`;

// Turno 2: Refinamiento basado en respuesta
const refinementPrompt = `
Excelente arquitectura. Ahora necesito que ajustemos el store de Zustand para incluir:

- Estado de carga durante operaciones async
- Manejo de errores con mensajes user-friendly  
- Persistencia autom√°tica del token en localStorage
- Auto-refresh del token cuando est√© por expirar
- Cleanup del estado al logout

Tambi√©n quiero que siga nuestros patrones establecidos en el proyecto.
`;

// Turno 3: Implementaci√≥n espec√≠fica
const implementationPrompt = `
Perfecto. Ahora implementemos los formularios de login y registro usando:

- React Hook Form + Zod para validaci√≥n
- Nuestros componentes de UI existentes (Button, Input, Card)
- Estados de loading y error consistentes
- Redirecci√≥n autom√°tica despu√©s del login
- Validaci√≥n en tiempo real

Empecemos con el componente LoginForm.
`;
```

##### 2) Gesti√≥n del Historial de Conversaci√≥n

```typescript
interface ConversationManagement {
  // Mantener contexto coherente
  context_continuity: {
    strategy: "Referenciar decisiones previas en prompts siguientes";
    example: "Bas√°ndome en el store de auth que acabamos de crear...";
    benefits: ["C√≥digo consistente", "Patrones coherentes"];
  };
  
  // Construcci√≥n iterativa
  iterative_building: {
    approach: "Agregar complejidad gradualmente";
    phases: [
      "Estructura b√°sica y tipos",
      "Funcionalidad core",
      "Estados de loading/error", 
      "Optimizaciones de UX",
      "Testing y edge cases"
    ];
  };
  
  // Checkpoints de calidad
  quality_gates: {
    frequency: "Cada 3-4 turnos";
    questions: [
      "¬øSigue nuestros patrones establecidos?",
      "¬øMantiene type safety?",
      "¬øEs escalable y mantenible?",
      "¬øNecesitamos refactoring antes de continuar?"
    ];
  };
}
```

## T√©cnicas Avanzadas de Prompting

### Anatom√≠a de un Prompt Efectivo

#### Estructura Optimizada

```typescript
interface EffectivePrompt {
  // 1. Contexto claro y espec√≠fico
  context: {
    current_situation: "Estado actual del c√≥digo/proyecto";
    objective: "Qu√© queremos lograr espec√≠ficamente";
    constraints: "Limitaciones t√©cnicas o de negocio";
  };
  
  // 2. Especificaciones t√©cnicas
  technical_specs: {
    technologies: "Stack espec√≠fico a usar";
    patterns: "Patrones de c√≥digo a seguir";
    performance: "Requisitos de rendimiento";
    compatibility: "Compatibilidad necesaria";
  };
  
  // 3. Ejemplos y referencias
  examples: {
    similar_code: "Referencias en el proyecto";
    expected_output: "Formato esperado del resultado";
    edge_cases: "Casos especiales a manejar";
  };
  
  // 4. Criterios de √©xito
  success_criteria: {
    functional: "Qu√© debe hacer";
    quality: "C√≥mo debe hacerlo";
    testing: "C√≥mo verificar que funciona";
  };
}
```

#### Template de Prompt Profesional

```markdown
# Template para Prompts Estructurados

## Contexto
[Descripci√≥n clara del estado actual y objetivo]

## Requerimientos T√©cnicos
- **Stack**: [Tecnolog√≠as espec√≠ficas]
- **Patrones**: [Convenciones a seguir]
- **Performance**: [Requisitos espec√≠ficos]
- **Compatibilidad**: [Navegadores, devices, etc.]

## Referencias
- **C√≥digo similar**: @Files: [archivos relevantes]
- **Documentaci√≥n**: @Docs: [gu√≠as internas]
- **Ejemplos**: [c√≥digo existente en el proyecto]

## Criterios de √âxito
- [ ] Funcionalidad core implementada
- [ ] Sigue patrones establecidos del proyecto
- [ ] Incluye proper error handling
- [ ] TypeScript types correctos
- [ ] Tests unitarios incluidos

## Consideraciones Especiales
[Edge cases, optimizaciones, restricciones espec√≠ficas]
```

### Few-Shot Learning con Ejemplos de C√≥digo

#### T√©cnica: Mostrar Patrones Exitosos

```typescript
// Ejemplo de few-shot learning para custom hooks

const fewShotPrompt = `
Necesito crear un custom hook siguiendo nuestros patrones establecidos.

Ejemplos de nuestros hooks existentes:

**Ejemplo 1: Hook de API data**
\`\`\`typescript
export function useApiData<T>(url: string) {
  const [data, setData] = useState<T | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const fetchData = useCallback(async () => {
   try {
      setLoading(true);
      setError(null);
      const response = await fetch(url);
      if (!response.ok) throw new Error(\`HTTP \${response.status}\`);
      setData(await response.json());
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Error desconocido');
    } finally {
      setLoading(false);
    }
  }, [url]);

  useEffect(() => {
    fetchData();
  }, [fetchData]);

  return { data, loading, error, refetch: fetchData };
}
\`\`\`

**Ejemplo 2: Hook de local storage**
\`\`\`typescript
export function useLocalStorage<T>(
  key: string,
  initialValue: T
): [T, (value: T | ((val: T) => T)) => void] {
  const [storedValue, setStoredValue] = useState<T>(() => {
    try {
      const item = window.localStorage.getItem(key);
      return item ? JSON.parse(item) : initialValue;
    } catch (error) {
      console.warn(\`Error reading localStorage key "\${key}":, error\`);
      return initialValue;
    }
  });

  const setValue = useCallback((value: T | ((val: T) => T)) => {
    try {
      const valueToStore = value instanceof Function ? value(storedValue) : value;
      setStoredValue(valueToStore);
      window.localStorage.setItem(key, JSON.stringify(valueToStore));
    } catch (error) {
      console.warn(\`Error setting localStorage key "\${key}":, error\`);
    }
  }, [key, storedValue]);

  return [storedValue, setValue];
}
\`\`\`

Ahora crea un hook \`useDebounce\` que siga exactamente estos mismos patrones:
- TypeScript gen√©rico apropiado
- Error handling comprehensivo
- useCallback para funciones
- JSDoc documentation completa
- Nomenclatura consistente
`;
```

### Chain-of-Thought Prompting

#### Para Problemas Complejos

```typescript
const chainOfThoughtPrompt = `
Necesito optimizar el performance de nuestra app React. Trabajemos sistem√°ticamente:

**Paso 1: An√°lisis del Problema**
Primero analiza este componente e identifica bottlenecks:

@Files: src/components/ProductList.tsx, src/hooks/useProducts.ts

Busca espec√≠ficamente:
- Re-renders innecesarios
- Computaciones costosas en render
- Fetching de datos ineficiente
- Memory leaks potenciales

**Paso 2: Estrategia de Optimizaci√≥n**
Basado en el an√°lisis, determina:
- ¬øCu√°les optimizaciones tendr√°n mayor impacto?
- ¬øQu√© orden de implementaci√≥n es m√°s efectivo?
- ¬øHay trade-offs que debemos considerar?
- ¬øNecesitamos cambios arquitecturales?

**Paso 3: Implementaci√≥n**
Crea la versi√≥n optimizada con:
- React.memo donde sea beneficioso
- useMemo/useCallback estrat√©gicos
- Virtualizaci√≥n si es necesario
- Data fetching optimizado

**Paso 4: Validaci√≥n**
Explica c√≥mo medir las mejoras:
- M√©tricas de performance a trackear
- Herramientas de profiling recomendadas
- Tests de regresi√≥n necesarios

Empecemos con el Paso 1.
`;
```

## Anti-patrones y Mejores Pr√°cticas

### Errores Comunes de Prompting

<CardGrid>
  <Card title="‚ùå Prompts Vagos" icon="warning">
    **Malo**: "Haz que este c√≥digo sea mejor"
    
    **Bueno**: "Optimiza este componente React para performance reduciendo re-renders innecesarios"
  </Card>
  
  <Card title="‚ùå Sobrecarga de Contexto" icon="warning">
    **Malo**: "Aqu√≠ est√°n 50 archivos, arregla todos los bugs"
    
    **Bueno**: "@Files: componente espec√≠fico con bug identificado"
  </Card>
</CardGrid>

### Anti-Patrones de Desarrollo

#### Dependencia Ciega sin Revisi√≥n

```typescript
interface DevelopmentAntiPatterns {
  // Aceptar c√≥digo generado sin review
  blind_acceptance: {
    risks: [
      "Bugs introducidos sin detectar",
      "C√≥digo inconsistente con proyecto",
      "Vulnerabilidades de seguridad",
      "Patrones sub√≥ptimos propagados"
    ];
    solution: {
      always_review: "Revisar cada l√≠nea generada",
      test_thoroughly: "Probar todo c√≥digo de IA",
      validate_patterns: "Verificar consistencia",
      security_check: "Validar implicaciones de seguridad"
    };
  };
}
```

### Casos Donde NO Usar Cursor AI

| Escenario | Raz√≥n | Enfoque Recomendado |
|----------|--------|-------------------|
| **L√≥gica Cr√≠tica de Seguridad** | Requiere verificaci√≥n experta | Dise√±o humano + IA para implementaci√≥n |
| **Algoritmos de Dominio Espec√≠fico** | IA puede no entender sutilezas | Especificar requirements exactos |
| **Aprendizaje Fundamental** | El proceso de struggle es educativo | Usar IA como tutor, no solucionador |

## Ciclo √ìptimo: Prompt ‚Üí Revisi√≥n ‚Üí Aplicaci√≥n

### Workflow de Revisi√≥n Sistem√°tica

#### Fase 1: Pre-aplicaci√≥n

```typescript
interface OptimalWorkflow {
  pre_application: {
    code_quality_check: [
      "¬øSigue patrones del proyecto?",
      "¬øTypeScript types correctos?",
      "¬øError handling apropiado?",
      "¬øC√≥digo legible y mantenible?"
    ];
    
    functional_validation: [
      "¬øResuelve el problema planteado?",
      "¬øCumple todos los requirements?",
      "¬øManeja casos edge?",
      "¬øEs la soluci√≥n √≥ptima?"
    ];
  };
}
```

#### M√©tricas de Efectividad

| KPI | Objetivo |
|-----|----------|
| **Acceptance Rate** | > 80% de sugerencias aceptadas sin modificaci√≥n |
| **Iteration Count** | < 3 prompts promedio por tarea completada |
| **Time to Solution** | < 10 minutos para tareas est√°ndar |
| **Quality Score** | > 8/10 en calidad de c√≥digo post-aplicaci√≥n |

## AI Commit Messages

### Configuraci√≥n Optimizada

```json
// .cursor/config/commit-messages.json
{
  "ai_commit_messages": {
    "enabled": true,
    "auto_generate": true,
    "review_before_commit": true,
    
    "message_format": {
      "style": "conventional_commits",
      "include_scope": true,
      "max_length": 72,
      "include_body": true
    },
    
    "analysis_depth": {
      "understand_business_logic": true,
      "detect_breaking_changes": true,
      "identify_bug_fixes": true,
      "categorize_refactoring": true
    }
  }
}
```

### Ejemplos de Commit Messages de Calidad

```bash
# Feature nueva
feat(auth): implement OAuth 2.0 integration with Google

- Add GoogleAuthProvider component with error handling
- Implement token refresh mechanism with retry logic
- Update user store to handle OAuth user data structure
- Add comprehensive tests for OAuth flow

Breaking Change: User.authProvider field is now required

# Bug fix
fix(checkout): resolve payment validation edge case

- Handle empty cart state in payment processing
- Fix race condition in discount code application  
- Add proper error messages for failed payments
- Improve retry logic for network failures

Closes #1234

# Performance improvement
perf(dashboard): optimize data loading and rendering

- Implement React.memo for expensive components
- Add virtualization for large product lists
- Use useMemo for complex calculations
- Reduce API calls by 40% with intelligent caching

Improves initial load time from 3.2s to 1.1s
```

:::tip[Configuraci√≥n Avanzada]
Para configuraciones avanzadas de AI Commit Messages, consulta [AI Commit Guide](https://docs.cursor.com/ai-commits).
:::

## Troubleshooting de Workflow Com√∫n

### Problemas Frecuentes y Soluciones

#### Prompts no generan resultados esperados
```bash
# Verificar contexto disponible
cursor --show-context-analysis
```

#### Conversaciones se vuelven inconsistentes
1. Reiniciar conversaci√≥n en Composer
2. Establecer contexto claro desde el inicio
3. Referenciar decisiones previas expl√≠citamente

#### IA genera c√≥digo que no sigue patrones del proyecto
```bash
# Verificar reglas activas
cursor --validate-rules .cursor/rules/
```

:::tip[M√°s Ayuda]
Para m√°s problemas de workflow, consulta [Workflow Troubleshooting](https://docs.cursor.com/troubleshooting/workflow).
:::

## Pr√≥ximo Paso

¬°Has completado el M√≥dulo 3! Ahora dominas las t√©cnicas avanzadas de prompting y flujo de trabajo con Cursor AI. En el [M√≥dulo 4](/modulo-4/), aprender√°s a aplicar estas habilidades en casos de uso reales: desarrollo full-stack, testing automatizado y optimizaci√≥n de performance.