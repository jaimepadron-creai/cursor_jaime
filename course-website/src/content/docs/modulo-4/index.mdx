---
title: "MÃ³dulo 4: Desarrollo Frontend con Cursor AI"
description: Transforma arquitectura legacy a feature-based, implementa React patterns modernos, state management avanzado, API integration y optimizaciÃ³n de performance.
---

import { Card, CardGrid } from '@astrojs/starlight/components';

## Objetivos de Aprendizaje

Al finalizar este mÃ³dulo, serÃ¡s capaz de:

1. **Transformar** arquitectura frontend legacy a **feature-based architecture** escalable
2. **Implementar React patterns avanzados**: Compound Components, Render Props, y Custom Hooks
3. **Gestionar estado complejo** con Context API y React Query para cache inteligente
4. **Integrar APIs** con patterns profesionales de error handling y optimizaciÃ³n
5. **Optimizar performance** con React.memo, lazy loading y code splitting
6. **Desarrollar testing automatizado** con Jest, React Testing Library y E2E testing

## ğŸ“¹ Videos del MÃ³dulo

### ğŸ¯ Video Principal: Frontend con React

Aprende a desarrollar frontend moderno con React usando Cursor AI.

<iframe 
  width="100%" 
  height="400" 
  src="https://www.youtube.com/embed/Rgz6mX93C4Y" 
  title="Frontend con React y Cursor AI" 
  frameborder="0" 
  allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" 
  allowfullscreen
  style="border-radius: 8px; margin: 1rem 0;">
</iframe>

### ğŸ› ï¸ Video Complementario: Componentes y Estado

Manejo avanzado de componentes React y gestiÃ³n de estado.

<iframe 
  width="100%" 
  height="400" 
  src="https://www.youtube.com/embed/nafcNqVas2A" 
  title="Componentes y Estado en React" 
  frameborder="0" 
  allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" 
  allowfullscreen
  style="border-radius: 8px; margin: 1rem 0;">
</iframe>

## IntroducciÃ³n Conceptual

El desarrollo frontend moderno va mÃ¡s allÃ¡ de crear componentes que "funcionan"â€”se trata de **arquitectar sistemas escalables** que puedan evolucionar con equipos de desarrollo crecientes y requerimientos cambiantes. Este mÃ³dulo te enseÃ±a a usar Cursor AI para transformar aplicaciones frontend legacy en **arquitecturas empresariales robustas**.

La **Feature-Based Architecture** es el estÃ¡ndar de facto para aplicaciones React empresariales porque resuelve los problemas fundamentales del frontend: escalabilidad, mantenibilidad, testabilidad y colaboraciÃ³n en equipo. AprenderÃ¡s a implementar esta arquitectura usando Cursor AI como tu copiloto de desarrollo.

Al final de este mÃ³dulo, habrÃ¡s transformado un frontend bÃ¡sico en una **aplicaciÃ³n enterprise-ready** con patrones modernos, performance optimizada y testing automatizado.

## Feature-Based Architecture

### Â¿Por quÃ© Feature-Based Architecture?

#### Problemas del Frontend Legacy

```typescript
// âŒ ANTES: Estructura plana y desordenada
src/
â”œâ”€â”€ components/
â”‚   â”œâ”€â”€ Header.tsx
â”‚   â”œâ”€â”€ Footer.tsx
â”‚   â”œâ”€â”€ ProductCard.tsx
â”‚   â”œâ”€â”€ UserProfile.tsx
â”‚   â””â”€â”€ OrderList.tsx
â”œâ”€â”€ pages/
â”‚   â”œâ”€â”€ HomePage.tsx
â”‚   â”œâ”€â”€ ProductsPage.tsx
â”‚   â””â”€â”€ OrdersPage.tsx
â””â”€â”€ utils/
    â”œâ”€â”€ api.ts
    â””â”€â”€ helpers.ts
```

#### SoluciÃ³n: Feature-Based Architecture

```typescript
// âœ… DESPUÃ‰S: OrganizaciÃ³n por funcionalidad
src/
â”œâ”€â”€ features/
â”‚   â”œâ”€â”€ Auth/
â”‚   â”‚   â”œâ”€â”€ components/
â”‚   â”‚   â”œâ”€â”€ pages/
â”‚   â”‚   â”œâ”€â”€ store/
â”‚   â”‚   â””â”€â”€ utils/
â”‚   â”œâ”€â”€ Products/
â”‚   â”‚   â”œâ”€â”€ components/
â”‚   â”‚   â”œâ”€â”€ pages/
â”‚   â”‚   â”œâ”€â”€ store/
â”‚   â”‚   â””â”€â”€ utils/
â”‚   â””â”€â”€ Orders/
â”‚       â”œâ”€â”€ components/
â”‚       â”œâ”€â”€ pages/
â”‚       â”œâ”€â”€ store/
â”‚       â””â”€â”€ utils/
â”œâ”€â”€ shared/
â”‚   â”œâ”€â”€ components/
â”‚   â”œâ”€â”€ hooks/
â”‚   â””â”€â”€ utils/
â””â”€â”€ App.tsx
```

### Beneficios de la Arquitectura Moderna

<CardGrid>
  <Card title="ğŸ”§ Escalabilidad" icon="rocket">
    FÃ¡cil agregar nuevas features sin romper cÃ³digo existente
  </Card>
  
  <Card title="ğŸ› ï¸ Mantenibilidad" icon="setting">
    CÃ³digo organizado y predecible con responsabilidades claras
  </Card>
  
  <Card title="â™»ï¸ ReutilizaciÃ³n" icon="puzzle">
    Componentes compartidos optimizados para toda la aplicaciÃ³n
  </Card>
  
  <Card title="ğŸ§ª Testing" icon="approve-check">
    Tests aislados por feature con mocking simplificado
  </Card>
</CardGrid>

### Principios Fundamentales

#### 1. SeparaciÃ³n por Dominio

```typescript
// Cada feature representa un dominio de negocio
features/
â”œâ”€â”€ Auth/          // AutenticaciÃ³n y autorizaciÃ³n
â”œâ”€â”€ Products/      // GestiÃ³n de productos
â”œâ”€â”€ Orders/        // GestiÃ³n de Ã³rdenes
â”œâ”€â”€ Users/         // GestiÃ³n de usuarios
â””â”€â”€ Admin/         // Panel administrativo
```

#### 2. Estructura Interna de Features

```typescript
features/Products/
â”œâ”€â”€ components/    // Componentes especÃ­ficos del dominio
â”‚   â”œâ”€â”€ ProductCard.tsx
â”‚   â”œâ”€â”€ ProductList.tsx
â”‚   â””â”€â”€ ProductDetail.tsx
â”œâ”€â”€ pages/         // PÃ¡ginas del dominio
â”‚   â”œâ”€â”€ ProductsPage.tsx
â”‚   â””â”€â”€ ProductDetailPage.tsx
â”œâ”€â”€ store/         // Estado local del dominio
â”‚   â”œâ”€â”€ productsSlice.ts
â”‚   â””â”€â”€ productsActions.ts
â”œâ”€â”€ hooks/         // Hooks especÃ­ficos del dominio
â”‚   â”œâ”€â”€ useProducts.ts
â”‚   â””â”€â”€ useProduct.ts
â”œâ”€â”€ utils/         // Utilidades del dominio
â”‚   â”œâ”€â”€ productHelpers.ts
â”‚   â””â”€â”€ productValidators.ts
â””â”€â”€ types/         // Tipos TypeScript del dominio
    â””â”€â”€ product.types.ts
```

### ImplementaciÃ³n PrÃ¡ctica

#### Ejemplo: Feature Products

```typescript
// features/Products/types/product.types.ts
export interface Product {
  id: number;
  name: string;
  price: number;
  description: string;
  category: string;
  stock: number;
  imageUrl?: string;
}

export interface ProductFilters {
  category?: string;
  minPrice?: number;
  maxPrice?: number;
  search?: string;
}

// features/Products/hooks/useProducts.ts
import { useState, useEffect } from 'react';
import { Product, ProductFilters } from '../types/product.types';
import { productsApi } from '../utils/productsApi';

export const useProducts = (filters?: ProductFilters) => {
  const [products, setProducts] = useState<Product[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const fetchProducts = async () => {
      try {
        setLoading(true);
        const data = await productsApi.getProducts(filters);
        setProducts(data);
      } catch (err) {
        setError(err instanceof Error ? err.message : 'Error fetching products');
      } finally {
        setLoading(false);
      }
    };

    fetchProducts();
  }, [filters]);

  return { products, loading, error };
};
```

## React Patterns Avanzados

### 1. Compound Components Pattern

#### Ejemplo: ProductCard con Variantes

```tsx
// features/Products/components/ProductCard/ProductCard.tsx
import React from 'react';
import { Product } from '../../types/product.types';

interface ProductCardProps {
  product: Product;
  variant?: 'default' | 'compact' | 'detailed';
  onAddToCart?: (product: Product) => void;
  onViewDetails?: (product: Product) => void;
}

export const ProductCard: React.FC<ProductCardProps> = ({
  product,
  variant = 'default',
  onAddToCart,
  onViewDetails
}) => {
  const renderContent = () => {
    switch (variant) {
      case 'compact':
        return <ProductCardCompact product={product} />;
      case 'detailed':
        return <ProductCardDetailed product={product} />;
      default:
        return <ProductCardDefault product={product} />;
    }
  };

  return (
    <div className={`product-card product-card--${variant}`}>
      {renderContent()}
      <div className="product-card__actions">
        {onViewDetails && (
          <button onClick={() => onViewDetails(product)}>
            Ver Detalles
          </button>
        )}
        {onAddToCart && (
          <button onClick={() => onAddToCart(product)}>
            Agregar al Carrito
          </button>
        )}
      </div>
    </div>
  );
};

// Sub-componentes
const ProductCardDefault: React.FC<{ product: Product }> = ({ product }) => (
  <div className="product-card__content">
    <img src={product.imageUrl} alt={product.name} />
    <h3>{product.name}</h3>
    <p className="price">${product.price}</p>
  </div>
);

const ProductCardCompact: React.FC<{ product: Product }> = ({ product }) => (
  <div className="product-card__content--compact">
    <h4>{product.name}</h4>
    <p>${product.price}</p>
  </div>
);

const ProductCardDetailed: React.FC<{ product: Product }> = ({ product }) => (
  <div className="product-card__content--detailed">
    <img src={product.imageUrl} alt={product.name} />
    <h3>{product.name}</h3>
    <p className="description">{product.description}</p>
    <p className="price">${product.price}</p>
    <p className="stock">Stock: {product.stock}</p>
    <p className="category">{product.category}</p>
  </div>
);
```

### 2. Render Props Pattern

#### Ejemplo: Data Fetcher Reutilizable

```tsx
// shared/components/DataFetcher/DataFetcher.tsx
import React, { useState, useEffect } from 'react';

interface DataFetcherProps<T> {
  url: string;
  children: (data: T[], loading: boolean, error: string | null) => React.ReactNode;
}

export function DataFetcher<T>({ url, children }: DataFetcherProps<T>) {
  const [data, setData] = useState<T[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const fetchData = async () => {
      try {
        setLoading(true);
        const response = await fetch(url);
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        const result = await response.json();
        setData(result);
      } catch (err) {
        setError(err instanceof Error ? err.message : 'Error fetching data');
      } finally {
        setLoading(false);
      }
    };

    fetchData();
  }, [url]);

  return <>{children(data, loading, error)}</>;
}

// Uso en Products
<DataFetcher url="/api/products">
  {(products, loading, error) => {
    if (loading) return <div>Cargando productos...</div>;
    if (error) return <div>Error: {error}</div>;
    return <ProductList products={products} />;
  }}
</DataFetcher>
```

### 3. Custom Hooks Pattern

#### Ejemplo: useLocalStorage Hook

```typescript
// shared/hooks/useLocalStorage.ts
import { useState, useEffect } from 'react';

export function useLocalStorage<T>(key: string, initialValue: T) {
  // Estado para almacenar nuestro valor
  const [storedValue, setStoredValue] = useState<T>(() => {
    try {
      const item = window.localStorage.getItem(key);
      return item ? JSON.parse(item) : initialValue;
    } catch (error) {
      console.error(`Error reading localStorage key "${key}":`, error);
      return initialValue;
    }
  });

  // FunciÃ³n para establecer el valor
  const setValue = (value: T | ((val: T) => T)) => {
    try {
      const valueToStore = value instanceof Function ? value(storedValue) : value;
      setStoredValue(valueToStore);
      window.localStorage.setItem(key, JSON.stringify(valueToStore));
    } catch (error) {
      console.error(`Error setting localStorage key "${key}":`, error);
    }
  };

  return [storedValue, setValue] as const;
}

// Uso en Cart
const [cartItems, setCartItems] = useLocalStorage<CartItem[]>('cart', []);
```

## State Management con Context API

### ImplementaciÃ³n de Context API

#### 1. Auth Context

```tsx
// features/Auth/context/AuthContext.tsx
import React, { createContext, useContext, useReducer, ReactNode } from 'react';

interface User {
  id: number;
  email: string;
  name: string;
  role: 'customer' | 'admin';
}

interface AuthState {
  user: User | null;
  token: string | null;
  isAuthenticated: boolean;
  loading: boolean;
}

type AuthAction =
  | { type: 'LOGIN_START' }
  | { type: 'LOGIN_SUCCESS'; payload: { user: User; token: string } }
  | { type: 'LOGIN_FAILURE'; payload: string }
  | { type: 'LOGOUT' }
  | { type: 'UPDATE_USER'; payload: User };

const initialState: AuthState = {
  user: null,
  token: null,
  isAuthenticated: false,
  loading: false,
};

function authReducer(state: AuthState, action: AuthAction): AuthState {
  switch (action.type) {
    case 'LOGIN_START':
      return { ...state, loading: true };
    case 'LOGIN_SUCCESS':
      return {
        ...state,
        user: action.payload.user,
        token: action.payload.token,
        isAuthenticated: true,
        loading: false,
      };
    case 'LOGIN_FAILURE':
      return {
        ...state,
        user: null,
        token: null,
        isAuthenticated: false,
        loading: false,
      };
    case 'LOGOUT':
      return {
        ...state,
        user: null,
        token: null,
        isAuthenticated: false,
      };
    case 'UPDATE_USER':
      return {
        ...state,
        user: action.payload,
      };
    default:
      return state;
  }
}

interface AuthContextType extends AuthState {
  login: (email: string, password: string) => Promise<void>;
  logout: () => void;
  updateUser: (user: User) => void;
}

const AuthContext = createContext<AuthContextType | undefined>(undefined);

export function AuthProvider({ children }: { children: ReactNode }) {
  const [state, dispatch] = useReducer(authReducer, initialState);

  const login = async (email: string, password: string) => {
    try {
      dispatch({ type: 'LOGIN_START' });
      
      const response = await fetch('/api/auth/login', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ email, password }),
      });

      if (!response.ok) {
        throw new Error('Login failed');
      }

      const { user, token } = await response.json();
      dispatch({ type: 'LOGIN_SUCCESS', payload: { user, token } });
    } catch (error) {
      dispatch({ 
        type: 'LOGIN_FAILURE', 
        payload: error instanceof Error ? error.message : 'Login failed' 
      });
    }
  };

  const logout = () => {
    dispatch({ type: 'LOGOUT' });
  };

  const updateUser = (user: User) => {
    dispatch({ type: 'UPDATE_USER', payload: user });
  };

  return (
    <AuthContext.Provider value={{ ...state, login, logout, updateUser }}>
      {children}
    </AuthContext.Provider>
  );
}

export function useAuth() {
  const context = useContext(AuthContext);
  if (context === undefined) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
}
```

## API Integration Patterns

### 1. API Client con Axios

#### ConfiguraciÃ³n Base

```typescript
// shared/utils/apiClient.ts
import axios, { AxiosInstance, AxiosRequestConfig, AxiosResponse } from 'axios';

class ApiClient {
  private client: AxiosInstance;

  constructor() {
    this.client = axios.create({
      baseURL: process.env.REACT_APP_API_URL || 'http://localhost:8000',
      timeout: 10000,
      headers: {
        'Content-Type': 'application/json',
      },
    });

    this.setupInterceptors();
  }

  private setupInterceptors() {
    // Request interceptor para agregar token
    this.client.interceptors.request.use(
      (config) => {
        const token = localStorage.getItem('token');
        if (token) {
          config.headers.Authorization = `Bearer ${token}`;
        }
        return config;
      },
      (error) => Promise.reject(error)
    );

    // Response interceptor para manejar errores
    this.client.interceptors.response.use(
      (response) => response,
      (error) => {
        if (error.response?.status === 401) {
          localStorage.removeItem('token');
          window.location.href = '/login';
        }
        return Promise.reject(error);
      }
    );
  }

  async get<T>(url: string, config?: AxiosRequestConfig): Promise<T> {
    const response: AxiosResponse<T> = await this.client.get(url, config);
    return response.data;
  }

  async post<T>(url: string, data?: any, config?: AxiosRequestConfig): Promise<T> {
    const response: AxiosResponse<T> = await this.client.post(url, data, config);
    return response.data;
  }

  async put<T>(url: string, data?: any, config?: AxiosRequestConfig): Promise<T> {
    const response: AxiosResponse<T> = await this.client.put(url, data, config);
    return response.data;
  }

  async delete<T>(url: string, config?: AxiosRequestConfig): Promise<T> {
    const response: AxiosResponse<T> = await this.client.delete(url, config);
    return response.data;
  }
}

export const apiClient = new ApiClient();
```

### 2. React Query para Cache y Estado

#### ConfiguraciÃ³n de React Query

```tsx
// shared/providers/QueryProvider.tsx
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { ReactQueryDevtools } from '@tanstack/react-query-devtools';
import { ReactNode } from 'react';

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 5 * 60 * 1000, // 5 minutos
      cacheTime: 10 * 60 * 1000, // 10 minutos
      retry: 3,
      refetchOnWindowFocus: false,
    },
  },
});

export function QueryProvider({ children }: { children: ReactNode }) {
  return (
    <QueryClientProvider client={queryClient}>
      {children}
      <ReactQueryDevtools initialIsOpen={false} />
    </QueryClientProvider>
  );
}
```

#### Custom Hooks con React Query

```typescript
// features/Products/hooks/useProductsQuery.ts
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { productsApi } from '../services/productsApi';
import { Product, ProductFilters, CreateProductData } from '../types/product.types';

export function useProducts(filters?: ProductFilters) {
  return useQuery({
    queryKey: ['products', filters],
    queryFn: () => productsApi.getProducts(filters),
  });
}

export function useProduct(id: number) {
  return useQuery({
    queryKey: ['product', id],
    queryFn: () => productsApi.getProduct(id),
    enabled: !!id,
  });
}

export function useCreateProduct() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (data: CreateProductData) => productsApi.createProduct(data),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['products'] });
    },
  });
}

export function useUpdateProduct() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: ({ id, data }: { id: number; data: Partial<CreateProductData> }) =>
      productsApi.updateProduct(id, data),
    onSuccess: (_, { id }) => {
      queryClient.invalidateQueries({ queryKey: ['products'] });
      queryClient.invalidateQueries({ queryKey: ['product', id] });
    },
  });
}
```

## Performance Optimization

### 1. React.memo para MemoizaciÃ³n

#### Ejemplo: ProductCard Optimizado

```tsx
// features/Products/components/ProductCard/ProductCard.tsx
import React, { memo } from 'react';
import { Product } from '../../types/product.types';

interface ProductCardProps {
  product: Product;
  onAddToCart: (product: Product) => void;
  onViewDetails: (product: Product) => void;
}

export const ProductCard = memo<ProductCardProps>(({ 
  product, 
  onAddToCart, 
  onViewDetails 
}) => {
  const handleAddToCart = () => {
    onAddToCart(product);
  };

  const handleViewDetails = () => {
    onViewDetails(product);
  };

  return (
    <div className="product-card">
      <img src={product.imageUrl} alt={product.name} />
      <h3>{product.name}</h3>
      <p className="price">${product.price}</p>
      <div className="product-card__actions">
        <button onClick={handleViewDetails}>Ver Detalles</button>
        <button onClick={handleAddToCart}>Agregar al Carrito</button>
      </div>
    </div>
  );
});

ProductCard.displayName = 'ProductCard';
```

### 2. useMemo y useCallback

#### Ejemplo: ProductList Optimizado

```tsx
// features/Products/components/ProductList/ProductList.tsx
import React, { useMemo, useCallback } from 'react';
import { ProductCard } from '../ProductCard/ProductCard';
import { Product } from '../../types/product.types';

interface ProductListProps {
  products: Product[];
  onAddToCart: (product: Product) => void;
  onViewDetails: (product: Product) => void;
  filters?: {
    category?: string;
    minPrice?: number;
    maxPrice?: number;
  };
}

export const ProductList: React.FC<ProductListProps> = ({
  products,
  onAddToCart,
  onViewDetails,
  filters
}) => {
  // Memoizar productos filtrados
  const filteredProducts = useMemo(() => {
    return products.filter(product => {
      if (filters?.category && product.category !== filters.category) {
        return false;
      }
      if (filters?.minPrice && product.price < filters.minPrice) {
        return false;
      }
      if (filters?.maxPrice && product.price > filters.maxPrice) {
        return false;
      }
      return true;
    });
  }, [products, filters]);

  // Memoizar callbacks
  const handleAddToCart = useCallback((product: Product) => {
    onAddToCart(product);
  }, [onAddToCart]);

  const handleViewDetails = useCallback((product: Product) => {
    onViewDetails(product);
  }, [onViewDetails]);

  return (
    <div className="product-list">
      {filteredProducts.map(product => (
        <ProductCard
          key={product.id}
          product={product}
          onAddToCart={handleAddToCart}
          onViewDetails={handleViewDetails}
        />
      ))}
    </div>
  );
};
```

### 3. Lazy Loading y Code Splitting

#### Ejemplo: Route-based Code Splitting

```tsx
// App.tsx
import React, { Suspense, lazy } from 'react';
import { BrowserRouter as Router, Routes, Route } from 'react-router-dom';
import { LoadingSpinner } from './shared/components/LoadingSpinner';

// Lazy load pages
const HomePage = lazy(() => import('./features/Home/pages/HomePage'));
const ProductsPage = lazy(() => import('./features/Products/pages/ProductsPage'));
const ProductDetailPage = lazy(() => import('./features/Products/pages/ProductDetailPage'));
const OrdersPage = lazy(() => import('./features/Orders/pages/OrdersPage'));
const LoginPage = lazy(() => import('./features/Auth/pages/LoginPage'));

export function App() {
  return (
    <Router>
      <Suspense fallback={<LoadingSpinner />}>
        <Routes>
          <Route path="/" element={<HomePage />} />
          <Route path="/products" element={<ProductsPage />} />
          <Route path="/products/:id" element={<ProductDetailPage />} />
          <Route path="/orders" element={<OrdersPage />} />
          <Route path="/login" element={<LoginPage />} />
        </Routes>
      </Suspense>
    </Router>
  );
}
```

## Testing Frontend

### 1. Unit Testing con Jest y React Testing Library

#### Ejemplo: Test de ProductCard

```tsx
// features/Products/components/ProductCard/__tests__/ProductCard.test.tsx
import React from 'react';
import { render, screen, fireEvent } from '@testing-library/react';
import { ProductCard } from '../ProductCard';
import { Product } from '../../../types/product.types';

const mockProduct: Product = {
  id: 1,
  name: 'Test Product',
  price: 99.99,
  description: 'Test description',
  category: 'Electronics',
  stock: 10,
  imageUrl: 'test-image.jpg',
};

const mockOnAddToCart = jest.fn();
const mockOnViewDetails = jest.fn();

describe('ProductCard', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  it('renders product information correctly', () => {
    render(
      <ProductCard
        product={mockProduct}
        onAddToCart={mockOnAddToCart}
        onViewDetails={mockOnViewDetails}
      />
    );

    expect(screen.getByText('Test Product')).toBeInTheDocument();
    expect(screen.getByText('$99.99')).toBeInTheDocument();
    expect(screen.getByText('Electronics')).toBeInTheDocument();
    expect(screen.getByAltText('Test Product')).toHaveAttribute('src', 'test-image.jpg');
  });

  it('calls onAddToCart when add to cart button is clicked', () => {
    render(
      <ProductCard
        product={mockProduct}
        onAddToCart={mockOnAddToCart}
        onViewDetails={mockOnViewDetails}
      />
    );

    const addToCartButton = screen.getByText('Agregar al Carrito');
    fireEvent.click(addToCartButton);

    expect(mockOnAddToCart).toHaveBeenCalledWith(mockProduct);
  });

  it('calls onViewDetails when view details button is clicked', () => {
    render(
      <ProductCard
        product={mockProduct}
        onAddToCart={mockOnAddToCart}
        onViewDetails={mockOnViewDetails}
      />
    );

    const viewDetailsButton = screen.getByText('Ver Detalles');
    fireEvent.click(viewDetailsButton);

    expect(mockOnViewDetails).toHaveBeenCalledWith(mockProduct);
  });
});
```

## Ejercicios PrÃ¡cticos

### Ejercicio 1: Transformar a Feature-Based Architecture

<CardGrid>
  <Card title="ğŸ“‹ Objetivo" icon="document">
    Refactorizar el frontend legacy del proyecto e-commerce a una arquitectura feature-based escalable
  </Card>
  
  <Card title="ğŸ¯ Criterios de EvaluaciÃ³n" icon="approve-check">
    - Estructura feature-based implementada
    - Componentes legacy migrados correctamente  
    - Tipos TypeScript bien definidos
    - SeparaciÃ³n clara de responsabilidades
  </Card>
</CardGrid>

#### Prompts para Cursor AI

```typescript
// 1. AnÃ¡lisis del CÃ³digo Legacy
@cursor: "Analiza el cÃ³digo actual del frontend del proyecto e-commerce y identifica los problemas de arquitectura. Sugiere una estructura feature-based especÃ­fica para este proyecto"

// 2. Crear Estructura de Carpetas
@cursor: "Crea la estructura completa de carpetas para el proyecto e-commerce siguiendo feature-based architecture. Incluye: features/Products, features/Auth, features/Orders, features/Cart, shared/components, shared/hooks, shared/utils"

// 3. Migrar Componentes Legacy
@cursor: "Refactoriza el componente HomePage.tsx legacy del proyecto e-commerce a la nueva estructura. MuÃ©velo a features/Home/pages/HomePage.tsx y aplica mejores prÃ¡cticas de TypeScript"

// 4. Crear Tipos TypeScript
@cursor: "Genera los tipos TypeScript para el proyecto e-commerce. Incluye interfaces para Product, User, Order, CartItem, etc."
```

### Ejercicio 2: Implementar Feature Products

<CardGrid>
  <Card title="ğŸ›ï¸ Objetivo" icon="star">
    Desarrollar la feature Products completa para el e-commerce con componentes modernos y API integration
  </Card>
  
  <Card title="âœ… Resultado Esperado" icon="approve-check">
    - API service funcional con TypeScript
    - Custom hooks con React Query
    - Componentes reutilizables y tipados
    - Manejo de estados loading/error
  </Card>
</CardGrid>

#### Estructura Final Esperada

```typescript
features/Products/
â”œâ”€â”€ components/
â”‚   â”œâ”€â”€ ProductCard/
â”‚   â”‚   â”œâ”€â”€ ProductCard.tsx
â”‚   â”‚   â”œâ”€â”€ ProductCard.module.css
â”‚   â”‚   â””â”€â”€ __tests__/
â”‚   â””â”€â”€ ProductList/
â”‚       â”œâ”€â”€ ProductList.tsx
â”‚       â”œâ”€â”€ ProductList.module.css
â”‚       â””â”€â”€ __tests__/
â”œâ”€â”€ pages/
â”‚   â”œâ”€â”€ ProductsPage.tsx
â”‚   â””â”€â”€ ProductDetailPage.tsx
â”œâ”€â”€ hooks/
â”‚   â””â”€â”€ useProducts.ts
â”œâ”€â”€ services/
â”‚   â””â”€â”€ productsApi.ts
â”œâ”€â”€ types/
â”‚   â””â”€â”€ product.types.ts
â””â”€â”€ utils/
    â””â”€â”€ productHelpers.ts
```

## MÃ©tricas de TransformaciÃ³n

| MÃ©trica | Antes | DespuÃ©s | Mejora |
|---------|--------|---------|---------|
| **LÃ­neas de cÃ³digo** | ~200 | ~1,500 | 7.5x |
| **Componentes** | 3 bÃ¡sicos | 15+ modulares | 5x |
| **Features** | 0 | 3 completas | âˆ |
| **Performance** | BÃ¡sica | Optimizada | 3x |
| **Testing** | 0% | 80%+ | âˆ |
| **Mantenibilidad** | DifÃ­cil | FÃ¡cil | 10x |

### Skills Desarrollados

- âœ… **Feature-Based Architecture**
- âœ… **React Patterns avanzados**
- âœ… **State Management con Context API**
- âœ… **API Integration patterns**
- âœ… **Performance Optimization**
- âœ… **Testing automatizado**
- âœ… **TypeScript avanzado**
- âœ… **Cursor AI mastery**

:::tip[FilosofÃ­a de Prompts Efectivos]
**Regla de Oro**: "SÃ© especÃ­fico, contextual y progresivo"

**âŒ MAL**: "Haz un componente"

**âœ… BIEN**: "Crea un componente ProductCard para un e-commerce que muestre imagen, nombre, precio y botÃ³n de agregar al carrito. Usa TypeScript, CSS modules y sigue las mejores prÃ¡cticas de React 18"
:::

## Troubleshooting de Frontend ComÃºn

### Problemas Frecuentes y Soluciones

#### Componentes no se re-renderizan correctamente
```bash
# Verificar dependency arrays en useEffect/useMemo
npm run lint:hooks
```

#### Performance issues con listas grandes
1. Implementar React.memo en componentes de lista
2. Usar useCallback para event handlers
3. Considerar virtualizaciÃ³n para >1000 items

#### Context re-renders excesivos
```tsx
// Dividir contextos por funcionalidad
// Usar mÃºltiples providers especÃ­ficos en lugar de uno global
```

:::tip[MÃ¡s Ayuda]
Para mÃ¡s problemas de desarrollo frontend, consulta [Frontend Troubleshooting](https://docs.cursor.com/troubleshooting/frontend).
:::

## PrÃ³ximo Paso

Â¡Has completado el MÃ³dulo 4! Ahora tienes las habilidades para desarrollar arquitecturas frontend empresariales con Cursor AI. En el [MÃ³dulo 5](/modulo-5/), aprenderÃ¡s desarrollo backend profesional con FastAPI, bases de datos, APIs RESTful y arquitectura de microservicios.